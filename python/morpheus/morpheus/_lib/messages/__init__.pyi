"""

        -----------------------
        .. currentmodule:: morpheus._lib.messages
        .. autosummary::
           :toctree: _generate

        
"""
from __future__ import annotations
import cupy as cupy
import typing
__all__ = ['ControlMessage', 'ControlMessageType', 'DataLoaderRegistry', 'DataTable', 'InferenceMemory', 'InferenceMemoryFIL', 'InferenceMemoryNLP', 'MessageMeta', 'MutableTableCtxMgr', 'RawPacketMessage', 'ResponseMemory', 'ResponseMemoryProbs', 'TensorMemory', 'cupy']
class ControlMessage:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ControlMessage) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    def add_task(self, task_type: str, task: typing.Any | None) -> None:
        ...
    @typing.overload
    def config(self, config: typing.Any | None) -> None:
        ...
    @typing.overload
    def config(self) -> typing.Any | None:
        ...
    def copy(self) -> ControlMessage:
        ...
    def filter_timestamp(self, regex_filter: str) -> dict:
        """
        Retrieve timestamps matching a regex filter within a given group.
        """
    def get_metadata(self, key: typing.Any = None, default_value: typing.Any = None) -> typing.Any:
        ...
    def get_tasks(self) -> typing.Any | None:
        ...
    def get_timestamp(self, key: str, fail_if_nonexist: bool = False) -> typing.Any:
        """
        Retrieve the timestamp for a given group and key. Returns None if the timestamp does not exist and fail_if_nonexist is False.
        """
    def get_timestamps(self) -> dict:
        ...
    def has_metadata(self, key: str) -> bool:
        ...
    def has_task(self, task_type: str) -> bool:
        ...
    def list_metadata(self) -> list:
        ...
    @typing.overload
    def payload(self) -> MessageMeta:
        ...
    @typing.overload
    def payload(self, arg0: MessageMeta) -> None:
        ...
    @typing.overload
    def payload(self, meta: typing.Any) -> None:
        ...
    def remove_task(self, task_type: str) -> typing.Any | None:
        ...
    def set_metadata(self, key: str, value: typing.Any | None) -> None:
        ...
    def set_timestamp(self, key: str, timestamp: typing.Any) -> None:
        """
        Set a timestamp for a given key and group.
        """
    @typing.overload
    def task_type(self) -> ControlMessageType:
        ...
    @typing.overload
    def task_type(self, task_type: ControlMessageType) -> None:
        ...
    def tensor_count(self) -> int:
        ...
    @typing.overload
    def tensors(self) -> TensorMemory:
        ...
    @typing.overload
    def tensors(self, arg0: TensorMemory) -> None:
        ...
class ControlMessageType:
    """
    Members:
    
      INFERENCE
    
      NONE
    
      TRAINING
    """
    INFERENCE: typing.ClassVar[ControlMessageType]  # value = <ControlMessageType.INFERENCE: 1>
    NONE: typing.ClassVar[ControlMessageType]  # value = <ControlMessageType.INFERENCE: 1>
    TRAINING: typing.ClassVar[ControlMessageType]  # value = <ControlMessageType.TRAINING: 2>
    __members__: typing.ClassVar[dict[str, ControlMessageType]]  # value = {'INFERENCE': <ControlMessageType.INFERENCE: 1>, 'NONE': <ControlMessageType.INFERENCE: 1>, 'TRAINING': <ControlMessageType.TRAINING: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class DataLoaderRegistry:
    @staticmethod
    def contains(name: str) -> bool:
        ...
    @staticmethod
    def list() -> list[str]:
        ...
    @staticmethod
    def register_loader(name: str, loader: typing.Callable[[ControlMessage, dict], ControlMessage], throw_if_exists: bool = True) -> None:
        ...
    @staticmethod
    def unregister_loader(name: str, throw_if_not_exists: bool = True) -> None:
        ...
class DataTable:
    pass
class InferenceMemory(TensorMemory):
    def __init__(self, *, count: int, tensors: typing.Any = None) -> None:
        ...
    def get_input(self: TensorMemory, name: str) -> typing.Any:
        ...
    def set_input(self: TensorMemory, name: str, tensor: typing.Any) -> None:
        ...
class InferenceMemoryFIL(InferenceMemory):
    input__0: typing.Any
    seq_ids: typing.Any
    def __init__(self, *, count: int, input__0: typing.Any, seq_ids: typing.Any) -> None:
        ...
class InferenceMemoryNLP(InferenceMemory):
    input_ids: typing.Any
    input_mask: typing.Any
    seq_ids: typing.Any
    def __init__(self, *, count: int, input_ids: typing.Any, input_mask: typing.Any, seq_ids: typing.Any) -> None:
        ...
class MessageMeta:
    @staticmethod
    def make_from_file(arg0: str) -> MessageMeta:
        ...
    def __init__(self, df: typing.Any) -> None:
        ...
    def copy_dataframe(self) -> typing.Any:
        ...
    def copy_ranges(self, ranges: list[tuple[int, int]]) -> MessageMeta:
        ...
    def ensure_sliceable_index(self) -> str | None:
        ...
    def get_column_names(self) -> list[str]:
        ...
    @typing.overload
    def get_data(self) -> typing.Any:
        ...
    @typing.overload
    def get_data(self, columns: str) -> typing.Any:
        ...
    @typing.overload
    def get_data(self, columns: list[str]) -> typing.Any:
        ...
    @typing.overload
    def get_data(self, columns: None) -> typing.Any:
        ...
    def get_slice(self, start: int, stop: int) -> MessageMeta:
        ...
    def has_sliceable_index(self) -> bool:
        ...
    def mutable_dataframe(self) -> MutableTableCtxMgr:
        ...
    def set_data(self, arg0: typing.Any, arg1: typing.Any) -> None:
        ...
    @property
    def count(self) -> int:
        ...
    @property
    def df(self) -> typing.Any:
        ...
class MutableTableCtxMgr:
    def __enter__(self) -> typing.Any:
        ...
    def __exit__(self, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> None:
        ...
    def __getattr__(self, *args, **kwargs) -> None:
        ...
    def __getitem__(self, *args, **kwargs) -> None:
        ...
    def __setattr__(self, *args, **kwargs) -> None:
        ...
    def __setitem__(self, *args, **kwargs) -> None:
        ...
class RawPacketMessage:
    @property
    def gpu_mem(self) -> bool:
        ...
    @property
    def max_size(self) -> int:
        ...
    @property
    def num(self) -> int:
        ...
class ResponseMemory(TensorMemory):
    def __init__(self, *, count: int, tensors: typing.Any = None) -> None:
        ...
    def get_output(self: TensorMemory, name: str) -> typing.Any:
        ...
    def set_output(self: TensorMemory, name: str, tensor: typing.Any) -> None:
        ...
class ResponseMemoryProbs(ResponseMemory):
    probs: typing.Any
    def __init__(self, *, count: int, probs: typing.Any) -> None:
        ...
class TensorMemory:
    def __init__(self, *, count: int, tensors: typing.Any = None) -> None:
        ...
    def get_tensor(self, name: str) -> typing.Any:
        ...
    def get_tensors(self) -> dict[str, typing.Any]:
        ...
    def has_tensor(self, arg0: str) -> bool:
        ...
    def set_tensor(self, name: str, tensor: typing.Any) -> None:
        ...
    def set_tensors(self, tensors: dict[str, typing.Any]) -> None:
        ...
    @property
    def count(self) -> int:
        ...
    @property
    def tensor_names(self) -> list[str]:
        ...
__version__: str = '25.2.0'
